#include <bits/stdc++.h>
using namespace std;

// Macro to optimize input/output
#define optimize()                \
    ios_base::sync_with_stdio(0); \
    cin.tie(0);                   \
    cout.tie(0);

// Maximum limit for prime sieve
const int N = 2000000;

// Boolean array to store whether a number is prime or not
bool prime[900000001];

// Vector to store all primes up to N
vector<int> ans;

// Function to perform the Sieve of Eratosthenes to find all primes up to N
void sieve()
{
    // Iterate through all numbers from 2 to sqrt(N)
    for (int i = 2; i * i <= N; i++)
    {
        if (prime[i] == false) // If the number i is prime
        {
            // Mark all multiples of i as non-prime
            for (int j = i * i; j <= N; j += i)
            {
                prime[j] = true;
            }
        }
    }

    // After sieve, collect all prime numbers into the 'ans' vector
    for (int i = 2; i <= N; i++)
    {
        if (prime[i] == false) // If the number i is prime
            ans.push_back(i);
    }
}

// Function to apply the segmented sieve to find primes in the range [l, r]
void SegmentedSieve(int l, int r)
{
    // If l is 1, we adjust it since 1 is not a prime number
    if (l == 1)
        l++;

    // Length of the range [l, r]
    int len = r - l + 1;

    // Array to mark whether a number in the range [l, r] is prime or not
    int arr[len + 1];
    memset(arr, 0, len * sizeof(int)); // Initialize all elements as 0 (prime)

    // Iterate over all primes generated by the sieve
    for (int p : ans)
    {
        // We only need to mark multiples of p if p^2 <= r
        if (p * p <= r)
        {
            // Find the first multiple of p greater than or equal to l
            int i = (l / p) * p;
            if (i < l)
                i += p; // Adjust if i is less than l

            // Mark all multiples of p in the range [l, r] as non-prime
            for (; i <= r; i += p)
            {
                // Skip marking the prime number p itself as non-prime
                if (i != p && arr[i - l] == 0)
                {
                    arr[i - l] = 1; // Mark the number as non-prime
                }
            }
        }
    }

    // Print all the primes in the range [l, r]
    for (int i = 0; i < len; i++)
    {
        if (arr[i] == 0)           // If the number is still marked as prime
            cout << l + i << endl; // Print the prime number
    }
}

int main()
{
    optimize(); // Optimize input/output

    // Generate all primes up to N
    sieve();

    int t; // Number of test cases
    cin >> t;
    while (t--)
    {
        int l, r;
        cin >> l >> r;

        // Apply segmented sieve to find primes in the range [l, r]
        SegmentedSieve(l, r);
    }

    return 0;
}


//Other Approch 

/*
 Author : SALAH
"HARD WORK CAN CHANGE LUCK"
*/




/*
#include<bits/stdc++.h>
using namespace std;

#define optimize() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);

const int N = 2000000;  // This is the upper limit for primes
vector<int> ans;
bool prime[N+1];  // The sieve for generating primes up to N

// Function to implement the classic sieve of Eratosthenes
void sieve() {
    memset(prime, true, sizeof(prime));  // Mark all numbers as prime initially
    prime[0] = prime[1] = false;  // 0 and 1 are not prime
    
    for (int i = 2; i * i <= N; i++) {
        if (prime[i]) {
            for (int j = i * i; j <= N; j += i) {
                prime[j] = false;  // Mark multiples of i as non-prime
            }
        }
    }

    // Collect all primes up to N
    for (int i = 2; i <= N; i++) {
        if (prime[i]) {
            ans.push_back(i);
        }
    }
}

// Function to implement the segmented sieve for the range [l, r]
void SegmentedSieve(int l, int r) {
    if (l == 1) l = 2;  // 1 is not a prime number, so start from 2 if l is 1
    
    int len = r - l + 1;
    vector<int> arr(len, 0);  // Array to mark non-prime numbers in range [l, r]
    
    // Use primes up to sqrt(r) for marking multiples in the range [l, r]
    for (int p : ans) {
        if (p * p > r) break;  // No need to check primes greater than sqrt(r)
        
        // Find the first multiple of p in the range [l, r]
        int start = max(p * p, (l + p - 1) / p * p);  // The first multiple of p >= l
        for (int i = start; i <= r; i += p) {
            arr[i - l] = 1;  // Mark multiples of p as non-prime
        }
    }
    
    // Print the primes in the range [l, r]
    for (int i = 0; i < len; i++) {
        if (arr[i] == 0) {
            cout << l + i << endl;  // The number is prime
        }
    }
}

int main() {
    optimize();
    sieve();  // Precompute primes up to N
    
    int t;
    cin >> t;  // Number of test cases
    while (t--) {
        int l, r;
        cin >> l >> r;
        SegmentedSieve(l, r);  // Find primes in the range [l, r]
    }

    return 0;
}


*/